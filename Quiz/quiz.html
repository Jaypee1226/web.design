<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Concepts Quiz</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
        }
        
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        
        .quiz-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .question {
            margin-bottom: 20px;
            padding: 15px;
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }
        
        .options {
            margin-top: 10px;
        }
        
        .option {
            margin: 8px 0;
            padding: 10px;
            background-color: #e8f4fc;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .option:hover {
            background-color: #d4e6f1;
        }
        
        .option.selected {
            background-color: #3498db;
            color: white;
        }
        
        .option.correct {
            background-color: #2ecc71;
            color: white;
        }
        
        .option.incorrect {
            background-color: #e74c3c;
            color: white;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .results {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            background-color: #e8f4fc;
            display: none;
        }
        
        .progress {
            text-align: center;
            margin-bottom: 20px;
            color: #7f8c8d;
        }
        
        .explanation {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-left: 3px solid #3498db;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Database Concepts Quiz</h1>
    <p style="text-align: center;">Test your knowledge of PL/SQL, Data Warehousing, and Database Concepts</p>
    
    <div class="progress">Question <span id="current-question">1</span> of <span id="total-questions">10</span></div>
    
    <div class="quiz-container">
        <div id="question-container"></div>
        <button id="submit-btn" disabled>Submit Answer</button>
        <button id="next-btn" style="display: none;">Next Question</button>
    </div>
    
    <div class="results" id="results"></div>
    
    <script>
        const questions = [
            // PL/SQL Basics (10 questions)
            {
                category: "PL/SQL Basics",
                question: "Which of the following SQL statements can be directly executed in PL/SQL without using Dynamic SQL?",
                options: [
                    "CREATE TABLE statement (DDL)",
                    "GRANT statement (DCL)",
                    "SELECT statement with INTO clause",
                    "ALTER USER statement (DDL)"
                ],
                answer: 2,
                explanation: "In PL/SQL, you can directly execute SELECT statements (with INTO clause), DML statements (INSERT, UPDATE, DELETE), and transaction control statements. DDL and DCL statements require Dynamic SQL with EXECUTE IMMEDIATE."
            },
            {
                category: "PL/SQL Basics",
                question: "What is the purpose of the INTO clause in a PL/SQL SELECT statement?",
                options: [
                    "To specify the table to select data from",
                    "To name the PL/SQL variables that will store the returned values",
                    "To filter which rows are returned by the query",
                    "To specify the order of the returned rows"
                ],
                answer: 1,
                explanation: "The INTO clause in PL/SQL SELECT statements specifies the names of PL/SQL variables that will hold the values returned by the query. It appears between SELECT and FROM."
            },
            {
                category: "PL/SQL Basics",
                question: "Which of the following is NOT a valid DML operation in PL/SQL?",
                options: [
                    "INSERT",
                    "UPDATE",
                    "DELETE",
                    "CREATE"
                ],
                answer: 3,
                explanation: "CREATE is a DDL (Data Definition Language) statement, not DML (Data Manipulation Language). The main DML operations are INSERT, UPDATE, DELETE, and MERGE."
            },
            {
                category: "PL/SQL Basics",
                question: "What happens if a SELECT statement in PL/SQL returns no rows?",
                options: [
                    "The PL/SQL block continues execution with NULL values in the INTO variables",
                    "The NO_DATA_FOUND exception is raised",
                    "The TOO_MANY_ROWS exception is raised",
                    "The program crashes with a runtime error"
                ],
                answer: 1,
                explanation: "When a SELECT statement returns no rows, PL/SQL raises the predefined NO_DATA_FOUND exception. Proper exception handling should be implemented to deal with this case."
            },
            {
                category: "PL/SQL Basics",
                question: "Which statement is used to make pending database changes permanent?",
                options: [
                    "SAVEPOINT",
                    "COMMIT",
                    "ROLLBACK",
                    "END TRANSACTION"
                ],
                answer: 1,
                explanation: "COMMIT makes all pending changes in the current transaction permanent. ROLLBACK undoes them, and SAVEPOINT creates points within a transaction to which you can later roll back."
            },
            {
                category: "PL/SQL Basics",
                question: "What is the correct way to execute a DDL statement from within PL/SQL?",
                options: [
                    "Directly include the DDL statement in the PL/SQL block",
                    "Use the EXECUTE IMMEDIATE statement",
                    "Call a predefined procedure called EXEC_DDL",
                    "DDL statements cannot be executed from PL/SQL"
                ],
                answer: 1,
                explanation: "DDL statements must be executed using Dynamic SQL with the EXECUTE IMMEDIATE statement because they cannot be directly included in PL/SQL blocks."
            },
            {
                category: "PL/SQL Basics",
                question: "Which of the following is true about transaction control in PL/SQL?",
                options: [
                    "Each DML statement automatically commits the transaction",
                    "Transactions must be explicitly started with a BEGIN TRANSACTION statement",
                    "Changes are not permanent until a COMMIT is issued",
                    "PL/SQL does not support transaction control statements"
                ],
                answer: 2,
                explanation: "In PL/SQL, changes made by DML statements are not permanent until a COMMIT is issued. Transactions are implicitly started with the first DML statement and must be explicitly committed or rolled back."
            },
            {
                category: "PL/SQL Basics",
                question: "What happens if a SELECT statement in PL/SQL returns multiple rows?",
                options: [
                    "Only the first row is stored in the INTO variables",
                    "The TOO_MANY_ROWS exception is raised",
                    "The program crashes with a runtime error",
                    "All rows are concatenated into the INTO variables"
                ],
                answer: 1,
                explanation: "When a SELECT statement returns multiple rows but is expected to return only one (as with an INTO clause), PL/SQL raises the TOO_MANY_ROWS exception."
            },
            {
                category: "PL/SQL Basics",
                question: "Which of the following is NOT a valid PL/SQL block section?",
                options: [
                    "DECLARE",
                    "EXECUTE",
                    "BEGIN",
                    "EXCEPTION"
                ],
                answer: 1,
                explanation: "A PL/SQL block has three sections: DECLARE (optional), BEGIN (mandatory), and EXCEPTION (optional). There is no EXECUTE section."
            },
            {
                category: "PL/SQL Basics",
                question: "What is the purpose of the %TYPE attribute in PL/SQL?",
                options: [
                    "To specify the data type of a variable based on a database column",
                    "To determine the storage type of a table",
                    "To create a new data type",
                    "To check the type of a variable at runtime"
                ],
                answer: 0,
                explanation: "The %TYPE attribute lets you declare a variable with the same data type as a database column. For example: v_employee_name employees.last_name%TYPE;"

            },

            // Cursors (10 questions)
            {
                category: "Cursors",
                question: "Which cursor attribute would you use to check if a FETCH operation returned a row?",
                options: [
                    "%ISOPEN",
                    "%NOTFOUND",
                    "%ROWCOUNT",
                    "%FOUND"
                ],
                answer: 3,
                explanation: "%FOUND returns TRUE if the most recent FETCH returned a row. %NOTFOUND is the opposite (TRUE if no row was returned). %ISOPEN checks if the cursor is open, and %ROWCOUNT gives the number of rows fetched so far."
            },
            {
                category: "Cursors",
                question: "What is the implicit cursor in PL/SQL called?",
                options: [
                    "IMPLICIT",
                    "CUR",
                    "SQL",
                    "DEFAULT"
                ],
                answer: 2,
                explanation: "Oracle automatically creates an implicit cursor named SQL for all DML statements and SELECT statements that return a single row."
            },
            {
                category: "Cursors",
                question: "Which of the following is NOT a step in using an explicit cursor?",
                options: [
                    "DECLARE",
                    "OPEN",
                    "FETCH",
                    "EXECUTE"
                ],
                answer: 3,
                explanation: "The four steps for explicit cursors are: 1) DECLARE the cursor, 2) OPEN it, 3) FETCH rows from it, and 4) CLOSE it. There is no EXECUTE step."
            },
            {
                category: "Cursors",
                question: "What does the %ROWCOUNT cursor attribute return?",
                options: [
                    "The total number of rows in the table",
                    "The number of rows processed by the cursor so far",
                    "The maximum number of rows the cursor can hold",
                    "The number of rows that match the cursor's query"
                ],
                answer: 1,
                explanation: "%ROWCOUNT returns the number of rows fetched so far for an explicit cursor or the number of rows affected by the most recent SQL statement for the implicit cursor."
            },
            {
                category: "Cursors",
                question: "When is memory allocated for a cursor?",
                options: [
                    "When the cursor is declared",
                    "When the cursor is opened",
                    "When the first FETCH is executed",
                    "When the PL/SQL block begins execution"
                ],
                answer: 1,
                explanation: "Memory for a cursor is allocated when the cursor is opened, not when it's declared. The OPEN statement executes the query and identifies the active set of rows."
            },
            {
                category: "Cursors",
                question: "What happens if you try to FETCH from a cursor that is not open?",
                options: [
                    "The FETCH operation returns NULL values",
                    "An INVALID_CURSOR exception is raised",
                    "The cursor automatically opens itself",
                    "The program crashes with a runtime error"
                ],
                answer: 1,
                explanation: "Attempting to FETCH from a cursor that isn't open raises the INVALID_CURSOR exception (ORA-01001)."
            },
            {
                category: "Cursors",
                question: "Which cursor attribute would you check to determine if all rows have been fetched?",
                options: [
                    "%ISOPEN",
                    "%NOTFOUND",
                    "%FOUND",
                    "%ROWCOUNT"
                ],
                answer: 1,
                explanation: "%NOTFOUND returns TRUE when the most recent FETCH didn't return a row, indicating you've reached the end of the active set."
            },
            {
                category: "Cursors",
                question: "What is the advantage of using a parameterized cursor?",
                options: [
                    "It can return multiple rows",
                    "It can accept different values each time it's opened",
                    "It doesn't need to be explicitly closed",
                    "It executes faster than regular cursors"
                ],
                answer: 1,
                explanation: "Parameterized cursors can accept different parameter values each time they're opened, allowing you to reuse the same cursor for different queries."
            },
            {
                category: "Cursors",
                question: "Which of the following is true about implicit cursors?",
                options: [
                    "They must be declared explicitly",
                    "They can process multiple rows",
                    "They are managed entirely by Oracle",
                    "They must be explicitly closed"
                ],
                answer: 2,
                explanation: "Implicit cursors are automatically created by Oracle for SQL statements and are entirely managed by Oracle. You don't declare, open, fetch from, or close them."
            },
            {
                category: "Cursors",
                question: "What is the purpose of the WHERE CURRENT OF clause in an UPDATE or DELETE statement?",
                options: [
                    "To reference the current row in a cursor FOR loop",
                    "To update or delete the row most recently fetched by a cursor",
                    "To specify the current date in a condition",
                    "To limit the operation to rows in the current transaction"
                ],
                answer: 1,
                explanation: "The WHERE CURRENT OF clause in an UPDATE or DELETE statement references the row most recently fetched by an explicit cursor, allowing you to modify that specific row."

            },

            // Procedures and Functions (10 questions)
            {
                category: "Procedures and Functions",
                question: "What is the main difference between a procedure and a function in PL/SQL?",
                options: [
                    "Procedures can't have parameters while functions can",
                    "Functions must return exactly one value while procedures don't need to return anything",
                    "Procedures are stored in the database while functions are not",
                    "Functions can only be called from SQL statements"
                ],
                answer: 1,
                explanation: "The key difference is that functions must return exactly one value using a RETURN statement, while procedures perform actions without necessarily returning values (though they can have OUT parameters)."
            },
            {
                category: "Procedures and Functions",
                question: "Which parameter mode is the default if none is specified?",
                options: [
                    "IN",
                    "OUT",
                    "IN OUT",
                    "There is no default mode"
                ],
                answer: 0,
                explanation: "If no parameter mode is specified, the default is IN, meaning the parameter is for input only and cannot be modified by the subprogram."
            },
            {
                category: "Procedures and Functions",
                question: "Which of the following is NOT allowed in a function called from a SQL statement?",
                options: [
                    "SELECT statements",
                    "DML operations (INSERT, UPDATE, DELETE)",
                    "Using the RETURN statement",
                    "Declaring local variables"
                ],
                answer: 1,
                explanation: "Functions called from SQL statements must not perform DML operations, issue COMMIT or ROLLBACK statements, or modify package variables."
            },
            {
                category: "Procedures and Functions",
                question: "What is the purpose of the OR REPLACE option when creating a procedure?",
                options: [
                    "To automatically replace any existing procedure with the same name",
                    "To create a backup copy of the existing procedure",
                    "To mark the procedure as replaceable by other users",
                    "To allow the procedure to be called recursively"
                ],
                answer: 0,
                explanation: "OR REPLACE allows you to modify an existing procedure without having to first drop it. If the procedure exists, it's replaced; if not, it's created."
            },
            {
                category: "Procedures and Functions",
                question: "Which data dictionary view contains the source code of stored procedures?",
                options: [
                    "USER_OBJECTS",
                    "USER_SOURCE",
                    "USER_PROCEDURES",
                    "USER_CODE"
                ],
                answer: 1,
                explanation: "USER_SOURCE contains the source code of stored procedures, functions, and packages. USER_OBJECTS lists the objects but not their source, and USER_PROCEDURES contains additional information about procedures."
            },
            {
                category: "Procedures and Functions",
                question: "What happens if a function doesn't execute a RETURN statement?",
                options: [
                    "It returns NULL by default",
                    "A compile-time error occurs",
                    "A runtime error occurs when the function is called",
                    "The function executes but cannot be used in SQL statements"
                ],
                answer: 2,
                explanation: "If a function completes without executing a RETURN statement, PL/SQL raises the predefined exception PROGRAM_ERROR at runtime."
            },
            {
                category: "Procedures and Functions",
                question: "Which of the following is true about OUT parameters?",
                options: [
                    "They can only be used in functions",
                    "They return values to the calling program",
                    "They cannot be assigned values within the subprogram",
                    "They must have a default value"
                ],
                answer: 1,
                explanation: "OUT parameters are used to return values to the calling program. They can be used in both procedures and functions (though functions should primarily use RETURN)."
            },
            {
                category: "Procedures and Functions",
                question: "What is the advantage of using %TYPE for procedure parameters?",
                options: [
                    "It makes the procedure run faster",
                    "It automatically adjusts if the database column definition changes",
                    "It allows the parameter to accept multiple data types",
                    "It makes the procedure more secure"
                ],
                answer: 1,
                explanation: "Using %TYPE for parameters links them to database columns, so if the column definition changes, the procedure automatically adjusts without needing modification."
            },
            {
                category: "Procedures and Functions",
                question: "Which statement is used to remove a stored procedure from the database?",
                options: [
                    "DELETE PROCEDURE",
                    "DROP PROCEDURE",
                    "REMOVE PROCEDURE",
                    "ALTER PROCEDURE...DISABLE"
                ],
                answer: 1,
                explanation: "The DROP PROCEDURE statement removes a stored procedure from the database. Similar syntax is used for functions: DROP FUNCTION."
            },
            {
                category: "Procedures and Functions",
                question: "What is a benefit of using procedures and functions in PL/SQL?",
                options: [
                    "They reduce network traffic by executing on the server",
                    "They automatically optimize SQL statements",
                    "They eliminate the need for exception handling",
                    "They allow direct execution of DDL statements"
                ],
                answer: 0,
                explanation: "Stored subprograms execute on the server, reducing network traffic compared to sending multiple SQL statements from a client. They also promote code reuse and modularity."

            },

            // Packages and Triggers (10 questions)
            {
                category: "Packages and Triggers",
                question: "Which component of a package contains the executable code?",
                options: [
                    "Package specification",
                    "Package body",
                    "Both specification and body",
                    "Package header"
                ],
                answer: 1,
                explanation: "The package specification declares the public interface (what's accessible to other programs), while the package body contains the implementation (executable code) of the procedures and functions."
            },
            {
                category: "Packages and Triggers",
                question: "What is the primary purpose of a package in PL/SQL?",
                options: [
                    "To group related program objects together",
                    "To make programs run faster",
                    "To provide transaction control",
                    "To handle exceptions globally"
                ],
                answer: 0,
                explanation: "Packages are used to group related procedures, functions, variables, cursors, and exceptions together as a logical unit, promoting modularity and code organization."
            },
            {
                category: "Packages and Triggers",
                question: "Which of the following can be included in a package specification?",
                options: [
                    "Variable declarations",
                    "Procedure implementations",
                    "Private function declarations",
                    "Local cursor definitions"
                ],
                answer: 0,
                explanation: "The package specification can include declarations of variables, constants, cursors, exceptions, and subprograms (just the headers, not implementations)."
            },
            {
                category: "Packages and Triggers",
                question: "What happens if you drop a package specification?",
                options: [
                    "Only the specification is dropped",
                    "Both the specification and body are dropped",
                    "The body becomes invalid but remains",
                    "You cannot drop a specification without first dropping the body"
                ],
                answer: 1,
                explanation: "Dropping a package specification automatically drops the package body as well, since the body cannot exist without its specification."
            },
            {
                category: "Packages and Triggers",
                question: "Which type of trigger fires once for each row affected by a DML statement?",
                options: [
                    "Statement-level trigger",
                    "Row-level trigger",
                    "BEFORE trigger",
                    "INSTEAD OF trigger"
                ],
                answer: 1,
                explanation: "Row-level triggers fire once for each row affected by the DML statement. Statement-level triggers fire once for the entire statement regardless of how many rows are affected."
            },
            {
                category: "Packages and Triggers",
                question: "When does a BEFORE trigger execute?",
                options: [
                    "Before the triggering statement is parsed",
                    "Before the triggering statement executes",
                    "Before the database starts up",
                    "Before any other triggers on the same event"
                ],
                answer: 1,
                explanation: "A BEFORE trigger executes before the triggering statement executes, allowing you to modify values or prevent the operation if needed."
            },
            {
                category: "Packages and Triggers",
                question: "What is the purpose of an INSTEAD OF trigger?",
                options: [
                    "To replace the triggering statement with different operations",
                    "To execute additional operations after the triggering statement",
                    "To prevent the triggering statement from executing",
                    "To log the triggering statement for auditing"
                ],
                answer: 0,
                explanation: "INSTEAD OF triggers are primarily used with views to replace the triggering DML operation (which might not work directly on the view) with operations that modify the underlying tables."
            },
            {
                category: "Packages and Triggers",
                question: "Which of the following events can trigger a database trigger?",
                options: [
                    "User login (LOGON)",
                    "Database shutdown (SHUTDOWN)",
                    "Server errors (SERVERERROR)",
                    "All of the above"
                ],
                answer: 3,
                explanation: "Database triggers can fire on DML events (INSERT, UPDATE, DELETE), DDL events (CREATE, ALTER, DROP), and system events like LOGON, SHUTDOWN, and SERVERERROR."
            },
            {
                category: "Packages and Triggers",
                question: "What is the difference between a trigger and a stored procedure?",
                options: [
                    "Triggers cannot contain PL/SQL code",
                    "Triggers execute automatically in response to events",
                    "Stored procedures cannot be called directly",
                    "There is no difference"
                ],
                answer: 1,
                explanation: "Triggers execute automatically when their triggering event occurs, while stored procedures must be explicitly called by another program or user."
            },
            {
                category: "Packages and Triggers",
                question: "Which pseudorecords are available in row-level triggers?",
                options: [
                    ":NEW and :OLD",
                    ":BEFORE and :AFTER",
                    ":INSERT, :UPDATE, and :DELETE",
                    ":CHANGED and :ORIGINAL"
                ],
                answer: 0,
                explanation: "In row-level triggers, :NEW contains the new values for the row (for INSERT and UPDATE), and :OLD contains the old values (for UPDATE and DELETE)."

            },

            // Data Warehousing (10 questions)
            {
                category: "Data Warehousing",
                question: "What is the primary purpose of a data warehouse?",
                options: [
                    "To process real-time transactions",
                    "To store only current data for operational systems",
                    "To support business intelligence and analytics",
                    "To replace operational databases"
                ],
                answer: 2,
                explanation: "Data warehouses are designed for business intelligence and analytics, containing historical data from multiple sources. Operational databases handle real-time transaction processing."
            },
            {
                category: "Data Warehousing",
                question: "Which of the following is NOT a characteristic of a data warehouse?",
                options: [
                    "Subject-oriented",
                    "Volatile",
                    "Integrated",
                    "Time-variant"
                ],
                answer: 1,
                explanation: "The key characteristics of a data warehouse are: Subject-oriented, Integrated, Non-volatile (not changing frequently), and Time-variant (maintaining historical data)."
            },
            {
                category: "Data Warehousing",
                question: "What is the main difference between a data warehouse and an operational database?",
                options: [
                    "Data warehouses are smaller",
                    "Operational databases are optimized for read access",
                    "Data warehouses contain historical data",
                    "Operational databases don't use SQL"
                ],
                answer: 2,
                explanation: "The primary difference is that data warehouses maintain historical data for analysis, while operational databases focus on current data for day-to-day transactions."
            },
            {
                category: "Data Warehousing",
                question: "Which component of data warehouse architecture is responsible for extracting and loading data?",
                options: [
                    "Query Manager",
                    "Warehouse Manager",
                    "Load Manager",
                    "OLAP Server"
                ],
                answer: 2,
                explanation: "The Load Manager (or front-end component) performs all operations associated with extraction and loading of data into the warehouse, including transformations."
            },
            {
                category: "Data Warehousing",
                question: "What is a data mart?",
                options: [
                    "A small, specialized data warehouse for a specific department",
                    "A backup copy of the data warehouse",
                    "A temporary storage area for ETL processing",
                    "A metadata repository"
                ],
                answer: 0,
                explanation: "A data mart is a subset of a data warehouse focused on a particular subject area or department (like sales or finance), providing easier access to relevant data."
            },
            {
                category: "Data Warehousing",
                question: "Which type of data mart is created without using a central data warehouse?",
                options: [
                    "Dependent data mart",
                    "Independent data mart",
                    "Hybrid data mart",
                    "Relational data mart"
                ],
                answer: 1,
                explanation: "An independent data mart is created directly from operational systems without a central data warehouse, while dependent data marts get their data from a warehouse."
            },
            {
                category: "Data Warehousing",
                question: "What is the purpose of the staging area in a data warehouse?",
                options: [
                    "To present data to end users",
                    "To clean and process data before loading",
                    "To store metadata definitions",
                    "To archive old data"
                ],
                answer: 1,
                explanation: "The staging area is used to clean, transform, and prepare data from source systems before loading it into the data warehouse."
            },
            {
                category: "Data Warehousing",
                question: "Which of the following is NOT a tier in the three-tier data warehouse architecture?",
                options: [
                    "Bottom Tier (Data Warehouse Server)",
                    "Middle Tier (OLAP Server)",
                    "Top Tier (Client Tools)",
                    "ETL Tier (Transformation Engine)"
                ],
                answer: 3,
                explanation: "The three tiers are: 1) Bottom Tier (data warehouse server), 2) Middle Tier (OLAP server), and 3) Top Tier (client tools). ETL is part of the loading process, not a separate tier."
            },
            {
                category: "Data Warehousing",
                question: "What is the primary purpose of an Operational Data Store (ODS)?",
                options: [
                    "To support long-term trend analysis",
                    "To provide real-time or near-real-time data for operational reporting",
                    "To replace the data warehouse",
                    "To store metadata definitions"
                ],
                answer: 1,
                explanation: "An ODS provides current or near-real-time integrated data from operational systems for operational reporting, positioned between operational databases and the data warehouse."
            },
            {
                category: "Data Warehousing",
                question: "Which data warehouse schema is named for its star-like structure with a central fact table?",
                options: [
                    "Snowflake schema",
                    "Star schema",
                    "Galaxy schema",
                    "Normalized schema"
                ],
                answer: 1,
                explanation: "The star schema has a central fact table connected to dimension tables, resembling a star. Snowflake schema normalizes the dimensions, and galaxy schema has multiple fact tables."

            },

            // OLAP and Data Mining (10 questions)
            {
                category: "OLAP and Data Mining",
                question: "What does OLAP stand for?",
                options: [
                    "Online Analytical Processing",
                    "Object Linking and Processing",
                    "Offline Analysis Procedure",
                    "Operational Log Analysis Platform"
                ],
                answer: 0,
                explanation: "OLAP stands for Online Analytical Processing, which enables users to analyze multidimensional data interactively from multiple perspectives."
            },
            {
                category: "OLAP and Data Mining",
                question: "Which OLAP operation involves viewing data at a more detailed level (e.g., from quarters to months)?",
                options: [
                    "Roll-up",
                    "Drill-down",
                    "Slice",
                    "Dice"
                ],
                answer: 1,
                explanation: "Drill-down navigates from higher-level summary data to lower-level detail data. Roll-up does the opposite, summarizing data to a higher level."
            },
            {
                category: "OLAP and Data Mining",
                question: "Which type of OLAP system uses a relational database for storage?",
                options: [
                    "MOLAP",
                    "ROLAP",
                    "HOLAP",
                    "DOLAP"
                ],
                answer: 1,
                explanation: "ROLAP (Relational OLAP) uses relational databases, while MOLAP uses multidimensional databases. HOLAP is a hybrid approach combining both."
            },
            {
                category: "OLAP and Data Mining",
                question: "What is an OLAP cube?",
                options: [
                    "A physical cube-shaped storage device",
                    "A data structure that allows fast analysis across multiple dimensions",
                    "A type of database trigger",
                    "A visualization tool for 3D data"
                ],
                answer: 1,
                explanation: "An OLAP cube is a multidimensional data structure that organizes data for fast analysis across multiple dimensions (like time, geography, product)."
            },
            {
                category: "OLAP and Data Mining",
                question: "Which OLAP operation extracts data for a single value of one dimension (e.g., sales in 2020)?",
                options: [
                    "Drill-down",
                    "Slice",
                    "Dice",
                    "Pivot"
                ],
                answer: 1,
                explanation: "Slice extracts data for a single value of one dimension, creating a subset of the cube. Dice extracts data for multiple dimension values."
            },
            {
                category: "OLAP and Data Mining",
                question: "What is the purpose of the ETL process in data warehousing?",
                options: [
                    "To present data to end users",
                    "To extract, transform, and load data into the warehouse",
                    "To optimize query performance",
                    "To create OLAP cubes"
                ],
                answer: 1,
                explanation: "ETL (Extract, Transform, Load) is the process of gathering data from source systems, cleaning and transforming it, and loading it into the data warehouse."
            },
            {
                category: "OLAP and Data Mining",
                question: "Which data mining technique groups similar data items together?",
                options: [
                    "Classification",
                    "Cluster analysis",
                    "Regression analysis",
                    "Association rule learning"
                ],
                answer: 1,
                explanation: "Cluster analysis groups similar data items into clusters based on their characteristics, without predefined classes (unsupervised learning)."
            },
            {
                category: "OLAP and Data Mining",
                question: "What is the first phase in the CRISP-DM data mining methodology?",
                options: [
                    "Data Understanding",
                    "Business Understanding",
                    "Data Preparation",
                    "Modeling"
                ],
                answer: 1,
                explanation: "CRISP-DM phases are: 1) Business Understanding, 2) Data Understanding, 3) Data Preparation, 4) Modeling, 5) Evaluation, and 6) Deployment."
            },
            {
                category: "OLAP and Data Mining",
                question: "Which algorithm is used for constructing decision trees in data mining?",
                options: [
                    "k-Means",
                    "Apriori",
                    "C4.5",
                    "PageRank"
                ],
                answer: 2,
                explanation: "C4.5 is an algorithm for generating decision trees. k-Means is for clustering, Apriori for association rules, and PageRank for link analysis."
            },
            {
                category: "OLAP and Data Mining",
                question: "What is the difference between predictive and descriptive data mining?",
                options: [
                    "Predictive looks forward, descriptive looks backward",
                    "Descriptive is faster than predictive",
                    "Predictive only works with numeric data",
                    "There is no difference"
                ],
                answer: 0,
                explanation: "Predictive data mining forecasts future trends and behaviors, while descriptive data mining identifies patterns and relationships in historical data."
            }
        ];

        // Quiz state
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedOption = null;
        let quizCompleted = false;

        // DOM elements
        const questionContainer = document.getElementById('question-container');
        const submitBtn = document.getElementById('submit-btn');
        const nextBtn = document.getElementById('next-btn');
        const resultsDiv = document.getElementById('results');
        const currentQuestionSpan = document.getElementById('current-question');
        const totalQuestionsSpan = document.getElementById('total-questions');

        // Initialize quiz
        totalQuestionsSpan.textContent = questions.length;
        showQuestion();

        // Event listeners
        submitBtn.addEventListener('click', submitAnswer);
        nextBtn.addEventListener('click', nextQuestion);

        function showQuestion() {
            const question = questions[currentQuestionIndex];
            currentQuestionSpan.textContent = currentQuestionIndex + 1;
            
            let optionsHtml = '';
            question.options.forEach((option, index) => {
                optionsHtml += `
                    <div class="option" data-index="${index}">
                        ${option}
                    </div>
                `;
            });
            
            questionContainer.innerHTML = `
                <div class="question">
                    <h3>${question.question}</h3>
                    <div class="options">${optionsHtml}</div>
                    <div class="explanation" id="explanation"></div>
                </div>
            `;
            
            // Add event listeners to options
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', selectOption);
            });
            
            // Reset UI state
            submitBtn.disabled = true;
            nextBtn.style.display = 'none';
            resultsDiv.style.display = 'none';
            selectedOption = null;
        }

        function selectOption(e) {
            // Remove selected class from all options
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Add selected class to clicked option
            const selectedElement = e.target.closest('.option');
            selectedElement.classList.add('selected');
            
            // Store selected option index
            selectedOption = parseInt(selectedElement.dataset.index);
            
            // Enable submit button
            submitBtn.disabled = false;
        }

        function submitAnswer() {
            if (selectedOption === null) return;
            
            const question = questions[currentQuestionIndex];
            const options = document.querySelectorAll('.option');
            const explanationDiv = document.getElementById('explanation');
            
            // Disable all options
            options.forEach(opt => {
                opt.style.cursor = 'default';
                opt.removeEventListener('click', selectOption);
            });
            
            // Mark correct and incorrect answers
            options.forEach((opt, index) => {
                if (index === question.answer) {
                    opt.classList.add('correct');
                } else if (index === selectedOption && index !== question.answer) {
                    opt.classList.add('incorrect');
                }
            });
            
            // Update score if correct
            if (selectedOption === question.answer) {
                score++;
            }
            
            // Show explanation
            explanationDiv.textContent = question.explanation;
            explanationDiv.style.display = 'block';
            
            // Change button to Next
            submitBtn.style.display = 'none';
            nextBtn.style.display = 'block';
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizCompleted = true;
            questionContainer.style.display = 'none';
            nextBtn.style.display = 'none';
            
            resultsDiv.innerHTML = `
                <h2>Quiz Completed!</h2>
                <p>Your score: ${score} out of ${questions.length}</p>
                <p>Percentage: ${Math.round((score / questions.length) * 100)}%</p>
                <button onclick="location.reload()">Take Quiz Again</button>
            `;
            resultsDiv.style.display = 'block';
        }
    </script>
</body>
</html>