<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Concepts Quiz</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
        }

        h1,
        h2 {
            color: #2c3e50;
            text-align: center;
        }

        .quiz-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .question {
            margin-bottom: 20px;
            padding: 15px;
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }

        .options {
            margin-top: 10px;
        }

        .option {
            margin: 8px 0;
            padding: 10px;
            background-color: #e8f4fc;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .option:hover {
            background-color: #d4e6f1;
        }

        .option.selected {
            background-color: #3498db;
            color: white;
        }

        .option.correct {
            background-color: #2ecc71;
            color: white;
        }

        .option.incorrect {
            background-color: #e74c3c;
            color: white;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .results {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            background-color: #e8f4fc;
            display: none;
        }

        .progress {
            text-align: center;
            margin-bottom: 20px;
            color: #7f8c8d;
        }

        .explanation {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-left: 3px solid #3498db;
            display: none;
        }
    </style>
</head>

<body>
    <h1>Database Concepts Quiz</h1>
    <p style="text-align: center;">Test your knowledge of PL/SQL, Data Warehousing, and Database Concepts</p>

    <div class="progress">Question <span id="current-question">1</span> of <span id="total-questions">10</span></div>

    <div class="quiz-container">
        <div id="question-container"></div>
        <button id="submit-btn" disabled>Submit Answer</button>
        <button id="next-btn" style="display: none;">Next Question</button>
    </div>

    <div class="results" id="results"></div>

    <script>
const questions = [
    // PL/SQL Basics (15 questions)
    {
        question: "Which of the following SQL statements can be directly executed in PL/SQL without using Dynamic SQL?",
        options: [
            "CREATE TABLE statement (DDL)",
            "GRANT statement (DCL)",
            "SELECT statement with INTO clause",
            "ALTER USER statement (DDL)"
        ],
        answer: 2,
        explanation: "In PL/SQL, you can directly execute SELECT statements (with INTO clause), DML statements (INSERT, UPDATE, DELETE), and transaction control statements. DDL and DCL statements require Dynamic SQL with EXECUTE IMMEDIATE."
    },
    {
        question: "What is the purpose of the INTO clause in a PL/SQL SELECT statement?",
        options: [
            "To specify the table to select data from",
            "To name the PL/SQL variables that will store the returned values",
            "To define the join conditions between tables",
            "To filter which rows should be returned"
        ],
        answer: 1,
        explanation: "The INTO clause is mandatory in PL/SQL SELECT statements and specifies the names of PL/SQL variables that will hold the values returned by the query."
    },
    {
        question: "Which of the following is NOT a valid DML statement in PL/SQL?",
        options: [
            "INSERT",
            "UPDATE",
            "DELETE",
            "CREATE"
        ],
        answer: 3,
        explanation: "CREATE is a DDL (Data Definition Language) statement, not DML (Data Manipulation Language). The main DML statements are INSERT, UPDATE, DELETE, and MERGE."
    },
    {
        question: "What happens if a SELECT statement in PL/SQL returns more than one row without using a cursor?",
        options: [
            "Only the first row is stored in the variables",
            "An error occurs",
            "All rows are stored in an array",
            "The statement executes successfully"
        ],
        answer: 1,
        explanation: "A SELECT...INTO statement in PL/SQL expects exactly one row. If it returns multiple rows, Oracle raises the TOO_MANY_ROWS exception (ORA-01422)."
    },
    {
        question: "Which transaction control statement would you use to make pending database changes permanent?",
        options: [
            "COMMIT",
            "ROLLBACK",
            "SAVEPOINT",
            "SET TRANSACTION"
        ],
        answer: 0,
        explanation: "COMMIT makes all pending changes in the current transaction permanent. ROLLBACK undoes them, and SAVEPOINT creates markers within a transaction for partial rollback."
    },
    {
        question: "What is the implicit cursor in PL/SQL called?",
        options: [
            "CUR",
            "SQL",
            "IMPLICIT_CURSOR",
            "DEFAULT_CURSOR"
        ],
        answer: 1,
        explanation: "Oracle automatically creates an implicit cursor named SQL for all DML statements and SELECT statements that return a single row."
    },
    {
        question: "Which implicit cursor attribute would you check to see how many rows were affected by the most recent DML statement?",
        options: [
            "%FOUND",
            "%NOTFOUND",
            "%ROWCOUNT",
            "%ISOPEN"
        ],
        answer: 2,
        explanation: "SQL%ROWCOUNT returns the number of rows affected by the most recent SQL statement. %FOUND and %NOTFOUND are boolean attributes, and %ISOPEN always returns FALSE for implicit cursors."
    },
    {
        question: "What value does SQL%FOUND return after a SELECT statement finds no rows?",
        options: [
            "TRUE",
            "FALSE",
            "NULL",
            "0"
        ],
        answer: 1,
        explanation: "SQL%FOUND returns FALSE if the most recent SQL statement affected no rows. It returns TRUE if at least one row was affected."
    },
    {
        question: "Which PL/SQL construct would you use to conditionally execute statements based on multiple possible values?",
        options: [
            "IF-THEN-ELSE",
            "CASE",
            "LOOP",
            "GOTO"
        ],
        answer: 1,
        explanation: "The CASE expression is ideal for conditional logic based on multiple possible values. IF-THEN-ELSE is better for simple true/false conditions."
    },
    {
        question: "What is the main purpose of a PL/SQL record?",
        options: [
            "To store a single scalar value",
            "To group related data items as a unit",
            "To create database tables",
            "To define cursor structures"
        ],
        answer: 1,
        explanation: "A PL/SQL record is a composite datatype that groups related data items as a logical unit. Each field in the record has its own name and datatype."
    },
    {
        question: "Which declaration creates a record variable based on the structure of the EMPLOYEES table?",
        options: [
            "emp_record EMPLOYEES%TYPE",
            "emp_record TYPE IS RECORD OF EMPLOYEES",
            "emp_record EMPLOYEES%ROWTYPE",
            "emp_record RECORD LIKE EMPLOYEES"
        ],
        answer: 2,
        explanation: "%ROWTYPE creates a record variable with fields matching the columns of a table (EMPLOYEES in this case). Each field has the same name and datatype as the corresponding column."
    },
    {
        question: "What is the primary advantage of using %ROWTYPE for record declarations?",
        options: [
            "It improves performance",
            "It automatically adapts to changes in table structure",
            "It allows for custom field names",
            "It reduces memory usage"
        ],
        answer: 1,
        explanation: "The main advantage of %ROWTYPE is that it automatically adapts to changes in the table structure. If columns are added, removed, or modified, the record declaration doesn't need to change."
    },
    {
        question: "Which PL/SQL control structure executes a sequence of statements while a condition is true?",
        options: [
            "FOR loop",
            "Basic loop",
            "WHILE loop",
            "CASE statement"
        ],
        answer: 2,
        explanation: "The WHILE loop executes statements repeatedly as long as the specified condition remains true. The condition is evaluated before each iteration."
    },
    {
        question: "What is the key characteristic of a basic loop in PL/SQL?",
        options: [
            "It executes a fixed number of times",
            "It requires a counter variable",
            "It executes indefinitely without a condition",
            "It can only be used with cursors"
        ],
        answer: 2,
        explanation: "A basic loop has no built-in termination condition and will execute indefinitely unless you include an EXIT or EXIT WHEN statement."
    },
    {
        question: "Which statement would you use to exit a loop when a condition becomes true?",
        options: [
            "BREAK WHEN condition",
            "EXIT WHEN condition",
            "STOP IF condition",
            "TERMINATE ON condition"
        ],
        answer: 1,
        explanation: "EXIT WHEN condition immediately terminates the loop when the condition evaluates to true. You can also use EXIT without WHEN inside an IF statement."
    },

    // Cursors (15 questions)
    {
        question: "What is a cursor in PL/SQL?",
        options: [
            "A pointer to a database table",
            "A memory area for storing SQL statement processing information",
            "A type of PL/SQL record",
            "A database trigger"
        ],
        answer: 1,
        explanation: "A cursor is a private memory area allocated by Oracle to store information about processing a specific SQL statement, including the result set and current position in it."
    },
    {
        question: "When does Oracle automatically create an implicit cursor?",
        options: [
            "Only for SELECT statements",
            "Only for DML statements",
            "For all SQL statements except DDL",
            "For all SQL statements in PL/SQL"
        ],
        answer: 3,
        explanation: "Oracle creates an implicit cursor for every SQL statement executed in PL/SQL, including SELECT, INSERT, UPDATE, DELETE, and MERGE statements."
    },
    {
        question: "Which cursor attribute would you check to determine if the most recent FETCH returned a row?",
        options: [
            "%ISOPEN",
            "%NOTFOUND",
            "%ROWCOUNT",
            "%FOUND"
        ],
        answer: 3,
        explanation: "%FOUND returns TRUE if the most recent FETCH returned a row. %NOTFOUND returns the opposite (TRUE if no row was fetched)."
    },
    {
        question: "What value does %ISOPEN return for an implicit cursor?",
        options: [
            "TRUE",
            "FALSE",
            "NULL",
            "Depends on the cursor state"
        ],
        answer: 1,
        explanation: "For implicit cursors, %ISOPEN always returns FALSE because Oracle opens and closes implicit cursors automatically."
    },
    {
        question: "When would you need to use an explicit cursor?",
        options: [
            "For any SQL statement in PL/SQL",
            "For DML statements that affect multiple rows",
            "For SELECT statements that return more than one row",
            "For transaction control statements"
        ],
        answer: 2,
        explanation: "Explicit cursors are needed for SELECT statements that return multiple rows, allowing you to process one row at a time."
    },
    {
        question: "What is the first step in using an explicit cursor?",
        options: [
            "OPEN the cursor",
            "FETCH from the cursor",
            "DECLARE the cursor",
            "CLOSE the cursor"
        ],
        answer: 2,
        explanation: "The steps are: 1) DECLARE the cursor with a SELECT statement, 2) OPEN it, 3) FETCH rows, and 4) CLOSE it when done."
    },
    {
        question: "Which clause should NOT appear in the declaration of an explicit cursor?",
        options: [
            "SELECT",
            "FROM",
            "INTO",
            "WHERE"
        ],
        answer: 2,
        explanation: "The INTO clause appears in the FETCH statement for explicit cursors, not in the cursor declaration. The declaration includes SELECT, FROM, WHERE, etc."
    },
    {
        question: "What happens if you try to FETCH from a cursor that has reached the end of its active set?",
        options: [
            "An error occurs",
            "The first row is fetched again",
            "NULL values are returned",
            "The %NOTFOUND attribute becomes TRUE"
        ],
        answer: 3,
        explanation: "When FETCH reaches the end of the active set, no row is returned and %NOTFOUND becomes TRUE. No error occurs."
    },
    {
        question: "Which statement makes a cursor's active set available for fetching?",
        options: [
            "DECLARE",
            "OPEN",
            "FETCH",
            "EXECUTE"
        ],
        answer: 1,
        explanation: "The OPEN statement executes the cursor's query and identifies the active set (the rows that meet the query conditions)."
    },
    {
        question: "What is the purpose of the %ROWCOUNT cursor attribute?",
        options: [
            "To limit the number of rows returned",
            "To count the total rows in a table",
            "To track the number of rows fetched so far",
            "To check if any rows were affected"
        ],
        answer: 2,
        explanation: "%ROWCOUNT returns the number of rows fetched so far from an explicit cursor or affected by a DML operation for implicit cursors."
    },
    {
        question: "Which of the following is a best practice for cursor handling?",
        options: [
            "Never close cursors to improve performance",
            "Use implicit cursors for multi-row queries",
            "Close cursors when finished to free resources",
            "Declare cursors inside loops"
        ],
        answer: 2,
        explanation: "Always close cursors when done to free system resources. Other options are bad practices: always close cursors, use explicit for multi-row, and declare outside loops."
    },
    {
        question: "What is the advantage of a parameterized cursor?",
        options: [
            "It can return multiple result sets",
            "It can accept values when opened to filter results",
            "It automatically closes itself",
            "It doesn't need to be declared"
        ],
        answer: 1,
        explanation: "Parameterized cursors accept values when opened, allowing you to customize the query results without redeclaring the cursor."
    },
    {
        question: "How do you declare a cursor parameter?",
        options: [
            "In the DECLARE section before the cursor",
            "After the CURSOR keyword in parentheses",
            "In the OPEN statement",
            "As a PL/SQL variable with the same name"
        ],
        answer: 1,
        explanation: "Cursor parameters are declared in parentheses immediately after the cursor name in the CURSOR declaration, similar to procedure parameters."
    },
    {
        question: "Which cursor type is most efficient for large result sets?",
        options: [
            "Implicit cursor with SELECT...INTO",
            "Explicit cursor with a loop",
            "Cursor FOR loop",
            "Parameterized cursor"
        ],
        answer: 2,
        explanation: "The cursor FOR loop is generally most efficient for large result sets because Oracle handles opening, fetching, and closing automatically with optimized performance."
    },
    {
        question: "What does a cursor FOR loop automatically do that a regular explicit cursor doesn't?",
        options: [
            "Declare the cursor",
            "Open, fetch, and close the cursor",
            "Handle exceptions",
            "Process multiple result sets"
        ],
        answer: 1,
        explanation: "The cursor FOR loop automatically handles opening the cursor, fetching each row, and closing the cursor when done, reducing boilerplate code."
    },

    // Procedures and Functions (15 questions)
    {
        question: "What is a stored procedure in PL/SQL?",
        options: [
            "A named PL/SQL block that performs an action",
            "A SQL statement that creates tables",
            "A database trigger",
            "A cursor declaration"
        ],
        answer: 0,
        explanation: "A stored procedure is a named PL/SQL block that performs one or more actions, can accept parameters, and is stored in the database."
    },
    {
        question: "Which data dictionary view contains information about stored procedures?",
        options: [
            "USER_TABLES",
            "USER_VIEWS",
            "USER_OBJECTS",
            "USER_INDEXES"
        ],
        answer: 2,
        explanation: "USER_OBJECTS contains information about all schema objects including procedures, functions, packages, and triggers."
    },
    {
        question: "What is the default parameter mode if none is specified?",
        options: [
            "IN",
            "OUT",
            "IN OUT",
            "VARIADIC"
        ],
        answer: 0,
        explanation: "If no mode is specified, parameters default to IN mode, meaning they can be read but not modified by the procedure."
    },
    {
        question: "Which statement creates or replaces a procedure named CALC_BONUS?",
        options: [
            "CREATE PROCEDURE CALC_BONUS...",
            "CREATE OR REPLACE PROCEDURE CALC_BONUS...",
            "ALTER PROCEDURE CALC_BONUS...",
            "DEFINE PROCEDURE CALC_BONUS..."
        ],
        answer: 1,
        explanation: "CREATE OR REPLACE PROCEDURE is the correct syntax to create a new procedure or replace an existing one with the same name."
    },
    {
        question: "What is a key difference between procedures and functions?",
        options: [
            "Procedures can't have parameters",
            "Functions must return a value",
            "Procedures are stored in memory only",
            "Functions can't be called from SQL"
        ],
        answer: 1,
        explanation: "The key difference is that functions must return exactly one value using a RETURN statement, while procedures perform actions without necessarily returning values."
    },
    {
        question: "Which parameter mode allows a subprogram to pass a value back to the caller?",
        options: [
            "IN",
            "OUT",
            "IN OUT",
            "RETURN"
        ],
        answer: 1,
        explanation: "OUT parameters are used to pass values back to the caller. IN parameters pass values in, and IN OUT does both."
    },
    {
        question: "Where is the RETURN statement required?",
        options: [
            "In all procedures",
            "In all functions",
            "In all packages",
            "In all triggers"
        ],
        answer: 1,
        explanation: "Functions must have at least one RETURN statement to return a value. Procedures may have RETURN statements but they're optional and don't return values."
    },
    {
        question: "Which of these is NOT a valid way to call a procedure?",
        options: [
            "EXECUTE procedure_name;",
            "procedure_name();",
            "CALL procedure_name();",
            "SELECT procedure_name FROM dual;"
        ],
        answer: 3,
        explanation: "Procedures can't be called from SELECT statements. They're called with EXECUTE, CALL, or directly in PL/SQL blocks."
    },
    {
        question: "What is the advantage of using %TYPE for parameters?",
        options: [
            "Improves performance",
            "Automatically adapts to column type changes",
            "Allows NULL values",
            "Makes parameters optional"
        ],
        answer: 1,
        explanation: "Using %TYPE for parameters links them to database column types, so if the column definition changes, the procedure automatically adapts."
    },
    {
        question: "Which statement about function purity levels is correct?",
        options: [
            "Functions called from SQL must be WNDS",
            "All functions are automatically pure",
            "Purity levels don't affect SQL calls",
            "Only package functions have purity levels"
        ],
        answer: 0,
        explanation: "Functions called from SQL statements must at least be WNDS (Writes No Database State) meaning they don't modify database tables."
    },
    {
        question: "What is a benefit of using packages?",
        options: [
            "Reduced memory usage",
            "Better organization of related code",
            "Faster execution",
            "Automatic transaction control"
        ],
        answer: 1,
        explanation: "Packages primarily help organize related procedures, functions, variables, etc. into logical units, improving code maintainability."
    },
    {
        question: "Which component declares public package elements?",
        options: [
            "Package body only",
            "Package specification",
            "Both specification and body",
            "Package header"
        ],
        answer: 1,
        explanation: "The package specification declares public elements (visible to users of the package). The body contains implementation and private elements."
    },
    {
        question: "What happens if you modify a package specification?",
        options: [
            "Only the specification needs recompilation",
            "The body automatically recompiles",
            "Both specification and body are invalidated",
            "Nothing changes until you recompile both"
        ],
        answer: 2,
        explanation: "Changing the package specification invalidates the body because the body must conform to the specification."
    },
    {
        question: "Which statement removes a package body without removing the specification?",
        options: [
            "DROP PACKAGE package_name;",
            "DROP PACKAGE BODY package_name;",
            "DELETE PACKAGE BODY package_name;",
            "REMOVE PACKAGE BODY package_name;"
        ],
        answer: 1,
        explanation: "DROP PACKAGE BODY removes just the body, leaving the specification intact. DROP PACKAGE removes both."
    },
    {
        question: "What is a package initialization section?",
        options: [
            "A required part of every package",
            "Code that runs when the package is first referenced",
            "A declaration of package constants",
            "The first procedure in a package"
        ],
        answer: 1,
        explanation: "The initialization section (after BEGIN in the package body) runs once when the package is first referenced in a session, typically for setup tasks."
    },

    // Triggers (15 questions)
    {
        question: "What is a database trigger?",
        options: [
            "A stored procedure that runs on demand",
            "A PL/SQL block that executes automatically when an event occurs",
            "A SQL statement that creates tables",
            "A type of cursor"
        ],
        answer: 1,
        explanation: "A trigger is a PL/SQL block that automatically executes (fires) when a specified database event occurs (DML, DDL, or system event)."
    },
    {
        question: "Which timing fires a trigger before the triggering statement executes?",
        options: [
            "BEFORE",
            "AFTER",
            "INSTEAD OF",
            "PRIOR"
        ],
        answer: 0,
        explanation: "BEFORE triggers fire before the triggering statement executes, allowing you to modify values or prevent operations."
    },
    {
        question: "What is the difference between row-level and statement-level triggers?",
        options: [
            "Row-level triggers fire once per statement",
            "Statement-level triggers fire once per affected row",
            "Row-level triggers fire once per affected row",
            "There is no difference"
        ],
        answer: 2,
        explanation: "Row-level triggers fire once for each row affected by the triggering statement. Statement-level triggers fire once per statement regardless of rows affected."
    },
    {
        question: "Which pseudorecord allows row-level triggers to access new column values?",
        options: [
            ":OLD",
            ":NEW",
            ":CURRENT",
            ":CHANGED"
        ],
        answer: 1,
        explanation: ":NEW is a pseudorecord that contains the new column values for INSERT or UPDATE operations in row-level triggers."
    },
    {
        question: "What can INSTEAD OF triggers be used for?",
        options: [
            "Tables only",
            "Views only",
            "Both tables and views",
            "Packages"
        ],
        answer: 1,
        explanation: "INSTEAD OF triggers are specifically for views, allowing modifications to views that would otherwise be non-updatable."
    },
    {
        question: "Which event can trigger a database event trigger?",
        options: [
            "User login",
            "Table update",
            "Procedure execution",
            "Package compilation"
        ],
        answer: 0,
        explanation: "Database event triggers fire on system events like user login (LOGON), logout (LOGOFF), startup (STARTUP), or shutdown (SHUTDOWN)."
    },
    {
        question: "What is the purpose of the FOLLOWS clause in trigger creation?",
        options: [
            "To specify trigger execution order",
            "To create dependent triggers",
            "To chain trigger execution",
            "To improve performance"
        ],
        answer: 0,
        explanation: "FOLLOWS specifies that a trigger should fire after another trigger of the same type (BEFORE/AFTER) on the same table, controlling execution order."
    },
    {
        question: "Which statement creates a trigger that fires after updates to the SALARY column?",
        options: [
            "CREATE TRIGGER trg1 AFTER UPDATE ON employees",
            "CREATE TRIGGER trg1 AFTER UPDATE OF salary ON employees",
            "CREATE TRIGGER trg1 ON employees AFTER salary UPDATE",
            "CREATE TRIGGER trg1 FOR UPDATE OF salary ON employees"
        ],
        answer: 1,
        explanation: "The correct syntax is CREATE TRIGGER...AFTER UPDATE OF column ON table to fire only when a specific column is updated."
    },
    {
        question: "What is a mutating table error?",
        options: [
            "When a trigger modifies its base table",
            "When a table is being altered",
            "When a table is locked",
            "When a table doesn't exist"
        ],
        answer: 0,
        explanation: "A mutating table error occurs when a trigger tries to query or modify the table that fired the trigger, creating a consistency problem."
    },
    {
        question: "How can you avoid mutating table errors?",
        options: [
            "Use statement-level triggers",
            "Use compound triggers",
            "Disable the trigger",
            "Both 1 and 2"
        ],
        answer: 3,
        explanation: "Mutating table errors can be avoided by using statement-level triggers (which don't see row changes) or compound triggers (which have separate timing points)."
    },
    {
        question: "What is a compound trigger?",
        options: [
            "A trigger with multiple events",
            "A trigger that combines multiple timing points",
            "A package of triggers",
            "A trigger with multiple actions"
        ],
        answer: 1,
        explanation: "A compound trigger combines multiple timing points (BEFORE/AFTER statement/row) in a single trigger, sharing state across timing points."
    },
    {
        question: "Which timing point in a compound trigger executes once per row before the row operation?",
        options: [
            "BEFORE STATEMENT",
            "AFTER STATEMENT",
            "BEFORE EACH ROW",
            "AFTER EACH ROW"
        ],
        answer: 2,
        explanation: "BEFORE EACH ROW executes once for each affected row before the row operation occurs."
    },
    {
        question: "What is the purpose of the WHEN clause in trigger creation?",
        options: [
            "To specify trigger timing",
            "To conditionally execute the trigger",
            "To define trigger order",
            "To specify trigger dependencies"
        ],
        answer: 1,
        explanation: "The WHEN clause allows you to specify a condition that must be true for the trigger to fire, providing conditional execution."
    },
    {
        question: "Which privilege is needed to create a trigger on another user's table?",
        options: [
            "CREATE TRIGGER",
            "ALTER on the table",
            "CREATE ANY TRIGGER",
            "ADMIN option"
        ],
        answer: 2,
        explanation: "CREATE ANY TRIGGER privilege is needed to create triggers on tables in another user's schema."
    },
    {
        question: "How can you temporarily disable a trigger?",
        options: [
            "ALTER TRIGGER trigger_name DISABLE",
            "DROP TRIGGER trigger_name",
            "REMOVE TRIGGER trigger_name",
            "DELETE TRIGGER trigger_name"
        ],
        answer: 0,
        explanation: "ALTER TRIGGER trigger_name DISABLE temporarily disables a trigger without dropping it. Use ENABLE to re-enable it."
    },

    // Data Warehousing (20 questions)
    {
        question: "What is the primary purpose of a data warehouse?",
        options: [
            "To process real-time transactions",
            "To support business decision-making through analysis",
            "To replace operational databases",
            "To store only current data"
        ],
        answer: 1,
        explanation: "Data warehouses are designed for business intelligence and analysis, containing historical data from multiple sources to support decision-making."
    },
    {
        question: "Which characteristic distinguishes a data warehouse from an operational database?",
        options: [
            "Data warehouses are optimized for read access",
            "Operational databases store historical data",
            "Data warehouses process transactions",
            "Operational databases are denormalized"
        ],
        answer: 0,
        explanation: "Data warehouses are optimized for complex queries and analysis (read access), while operational databases are optimized for transaction processing (write access)."
    },
    {
        question: "What does the 'S' in ETL stand for?",
        options: [
            "Sort",
            "Store",
            "System",
            "Staging"
        ],
        answer: 3,
        explanation: "ETL stands for Extract, Transform, Load. The 'S' is not part of the acronym - this is a trick question to test attention to detail!"
    },
    {
        question: "Which component of data warehouse architecture is responsible for extracting and loading data?",
        options: [
            "Warehouse Manager",
            "Load Manager",
            "Query Manager",
            "OLAP Server"
        ],
        answer: 1,
        explanation: "The Load Manager (or front-end component) handles extracting data from sources, transforming it, and loading it into the warehouse."
    },
    {
        question: "What is a data mart?",
        options: [
            "A complete copy of the data warehouse",
            "A subset of a data warehouse focused on a specific subject",
            "A temporary storage area for ETL processing",
            "An operational data store"
        ],
        answer: 1,
        explanation: "A data mart is a specialized subset of a data warehouse, typically focused on a specific business area like sales or finance."
    },
    {
        question: "Which type of data mart is created without using a central data warehouse?",
        options: [
            "Dependent",
            "Independent",
            "Hybrid",
            "Relational"
        ],
        answer: 1,
        explanation: "Independent data marts are created directly from operational systems without a central data warehouse, often leading to inconsistencies."
    },
    {
        question: "What is the central table in a star schema called?",
        options: [
            "Dimension table",
            "Fact table",
            "Lookup table",
            "Bridge table"
        ],
        answer: 1,
        explanation: "The fact table is the central table in a star schema, containing measurable business facts and foreign keys to dimension tables."
    },
    {
        question: "Which schema normalizes dimension tables into multiple related tables?",
        options: [
            "Star schema",
            "Snowflake schema",
            "Galaxy schema",
            "Flat schema"
        ],
        answer: 1,
        explanation: "The snowflake schema normalizes dimension tables into hierarchies of related tables, reducing redundancy but increasing query complexity."
    },
    {
        question: "What is the main advantage of a star schema over a snowflake schema?",
        options: [
            "Better storage efficiency",
            "Simpler queries",
            "More normalized structure",
            "Easier maintenance"
        ],
        answer: 1,
        explanation: "Star schemas typically provide simpler, faster queries due to denormalized dimensions and fewer joins compared to snowflake schemas."
    },
    {
        question: "Which OLAP operation summarizes data by climbing up a dimension hierarchy?",
        options: [
            "Drill-down",
            "Slice",
            "Roll-up",
            "Dice"
        ],
        answer: 2,
        explanation: "Roll-up (or drill-up) summarizes data by moving up a dimension hierarchy (e.g., from months to quarters to years)."
    },
    {
        question: "What does ROLAP stand for?",
        options: [
            "Relational OLAP",
            "Real-time OLAP",
            "Read-only OLAP",
            "Roll-up OLAP"
        ],
        answer: 0,
        explanation: "ROLAP stands for Relational OLAP, which uses relational databases to store and analyze multidimensional data."
    },
    {
        question: "Which OLAP system uses pre-calculated multidimensional cubes?",
        options: [
            "ROLAP",
            "MOLAP",
            "HOLAP",
            "DOLAP"
        ],
        answer: 1,
        explanation: "MOLAP (Multidimensional OLAP) stores data in optimized multidimensional cubes for fast analysis."
    },
    {
        question: "What is the purpose of a staging area in ETL?",
        options: [
            "To permanently store historical data",
            "To clean and transform data before loading",
            "To serve end-user queries",
            "To replace the data warehouse"
        ],
        answer: 1,
        explanation: "The staging area is a temporary storage area where data is cleaned, transformed, and prepared before being loaded into the data warehouse."
    },
    {
        question: "Which type of data extraction captures only changed data?",
        options: [
            "Full extraction",
            "Partial extraction with update notification",
            "Partial extraction without update notification",
            "Complete refresh"
        ],
        answer: 1,
        explanation: "Partial extraction with update notification captures only data that has changed since the last extraction, making it more efficient than full extracts."
    },
    {
        question: "What is the first phase in the CRISP-DM data mining methodology?",
        options: [
            "Data Understanding",
            "Business Understanding",
            "Data Preparation",
            "Modeling"
        ],
        answer: 1,
        explanation: "CRISP-DM begins with Business Understanding to define project objectives and requirements before moving to data and technical work."
    },
    {
        question: "Which data mining technique groups similar items together?",
        options: [
            "Classification",
            "Regression",
            "Clustering",
            "Association"
        ],
        answer: 2,
        explanation: "Clustering (or cluster analysis) groups similar items together based on their characteristics, without predefined categories."
    },
    {
        question: "What does the Apriori algorithm discover?",
        options: [
            "Decision trees",
            "Association rules",
            "Neural networks",
            "Regression models"
        ],
        answer: 1,
        explanation: "Apriori is a classic algorithm for learning association rules (e.g., 'customers who buy X often buy Y') from transactional data."
    },
    {
        question: "Which algorithm creates a hyperplane to separate data into classes?",
        options: [
            "k-Means",
            "Apriori",
            "SVM (Support Vector Machine)",
            "PageRank"
        ],
        answer: 2,
        explanation: "SVM (Support Vector Machine) creates an optimal hyperplane in high-dimensional space to separate data into classes."
    },
    {
        question: "What is the k in k-Means clustering?",
        options: [
            "The number of dimensions",
            "The number of clusters",
            "The kernel function",
            "The key attribute"
        ],
        answer: 1,
        explanation: "In k-Means, k represents the number of clusters to create. The algorithm partitions observations into exactly k clusters."
    },
    {
        question: "Which phase of CRISP-DM involves assessing model quality?",
        options: [
            "Data Preparation",
            "Modeling",
            "Evaluation",
            "Deployment"
        ],
        answer: 2,
        explanation: "The Evaluation phase assesses model quality and ensures it meets business objectives before deployment."
    }
];

        // Quiz state
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedOption = null;
        let quizCompleted = false;

        // DOM elements
        const questionContainer = document.getElementById('question-container');
        const submitBtn = document.getElementById('submit-btn');
        const nextBtn = document.getElementById('next-btn');
        const resultsDiv = document.getElementById('results');
        const currentQuestionSpan = document.getElementById('current-question');
        const totalQuestionsSpan = document.getElementById('total-questions');

        // Initialize quiz
        totalQuestionsSpan.textContent = questions.length;
        showQuestion();

        // Event listeners
        submitBtn.addEventListener('click', submitAnswer);
        nextBtn.addEventListener('click', nextQuestion);

        function showQuestion() {
            const question = questions[currentQuestionIndex];
            currentQuestionSpan.textContent = currentQuestionIndex + 1;

            let optionsHtml = '';
            question.options.forEach((option, index) => {
                optionsHtml += `
            <div class="option" data-index="${index}">
                ${option}
            </div>
        `;
            });

            questionContainer.innerHTML = `
        <div class="question">
            <h3>${question.question}</h3>
            <div class="options">${optionsHtml}</div>
            <div class="explanation" id="explanation"></div>
        </div>
    `;

            // Add event listeners to options
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', selectOption);
            });

            // Reset UI state
            submitBtn.disabled = true;
            nextBtn.style.display = 'none';
            resultsDiv.style.display = 'none';
            selectedOption = null;

            // Show the submit button when moving to the next question
            submitBtn.style.display = 'inline-block';
        }

        function selectOption(e) {
            // Remove selected class from all options
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Add selected class to clicked option
            const selectedElement = e.target.closest('.option');
            selectedElement.classList.add('selected');

            // Store selected option index
            selectedOption = parseInt(selectedElement.dataset.index);

            // Enable submit button
            submitBtn.disabled = false;
        }

        function submitAnswer() {
            if (selectedOption === null) return;

            const question = questions[currentQuestionIndex];
            const options = document.querySelectorAll('.option');
            const explanationDiv = document.getElementById('explanation');

            // Disable all options
            options.forEach(opt => {
                opt.style.cursor = 'default';
                opt.removeEventListener('click', selectOption);
            });

            // Mark correct and incorrect answers
            options.forEach((opt, index) => {
                if (index === question.answer) {
                    opt.classList.add('correct');
                } else if (index === selectedOption && index !== question.answer) {
                    opt.classList.add('incorrect');
                }
            });

            // Update score if correct
            if (selectedOption === question.answer) {
                score++;
            }

            // Show explanation
            explanationDiv.textContent = question.explanation;
            explanationDiv.style.display = 'block';

            // Change button to Next
            submitBtn.style.display = 'none';
            nextBtn.style.display = 'block';
        }

        function nextQuestion() {
            currentQuestionIndex++;

            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizCompleted = true;
            questionContainer.style.display = 'none';
            nextBtn.style.display = 'none';

            resultsDiv.innerHTML = `
                <h2>Quiz Completed!</h2>
                <p>Your score: ${score} out of ${questions.length}</p>
                <p>Percentage: ${Math.round((score / questions.length) * 100)}%</p>
                <button onclick="location.reload()">Take Quiz Again</button>
            `;
            resultsDiv.style.display = 'block';
        }
    </script>
</body>

</html>